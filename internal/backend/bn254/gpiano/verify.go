// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

// Modifications Copyright 2023 Tianyi Liu and Tiancheng Xie

package gpiano

import (
	"crypto/sha256"
	"fmt"
	"math/big"
	"runtime/debug"
	"time"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/sunblaze-ucb/simpleMPI/mpi"

	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	bn254witness "github.com/consensys/gnark/internal/backend/bn254/witness"

	"github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark/logger"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr/dkzg"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/kzg"
)

func Verify(proof *Proof, vk *VerifyingKey, publicWitness bn254witness.Witness) error {
	log := logger.Logger().With().Str("curve", "bn254").Str("backend", "gpiano").Logger()
	start := time.Now()

	// pick a hash function to derive the challenge (the same as in the prover)
	hFunc := sha256.New()

	// transcript to derive the challenge
	fs := fiatshamir.NewTranscript(hFunc, "gamma", "etaY", "etaX", "lambda", "alpha", "beta")

	// The first challenge is derived using the public data: the commitments to the permutation,
	// the coefficients of the circuit, and the public inputs.
	// derive gamma from the Comm(blinded cl), Comm(blinded cr), Comm(blinded co)
	if err := bindPublicData(&fs, "gamma", *vk, publicWitness); err != nil {
		return err
	}
	witnessPtrs := make([]*curve.G1Affine, len(proof.witnesses))
	for i := 0; i < len(proof.witnesses); i++ {
		witnessPtrs[i] = &proof.witnesses[i]
	}
	gamma, err := deriveRandomness(&fs, "gamma", false, witnessPtrs...)
	if err != nil {
		return err
	}
	// derive eta from Comm(l), Comm(r), Comm(o)
	etaY, err := deriveRandomness(&fs, "etaY", true)
	if err != nil {
		return err
	}
	etaX, err := deriveRandomness(&fs, "etaX", true)
	if err != nil {
		return err
	}

	// derive lambda from Comm(l), Comm(r), Comm(o), Com(Z)
	lambda, err := deriveRandomness(&fs, "lambda", true, &proof.Z, &proof.W)
	if err != nil {
		return err
	}

	// derive alpha, the point of evaluation
	alpha, err := deriveRandomness(&fs, "alpha", true, &proof.Hx[0], &proof.Hx[1], &proof.Hx[2], &proof.Hx[3])
	if err != nil {
		return err
	}

	// evaluation of Z=Xⁿ⁻¹ at α
	var alphaPowerN, zalpha fr.Element
	var bExpo big.Int
	one := fr.One()
	bExpo.SetUint64(vk.SizeX)
	alphaPowerN.Exp(alpha, &bExpo)
	zalpha.Sub(&alphaPowerN, &one)

	// compute the folded commitment to H: Comm(h₁) + αᵐ*Comm(h₂) + α²⁽ᵐ⁾*Comm(h₃)
	var alphaNBigInt big.Int
	alphaPowerN.ToBigIntRegular(&alphaNBigInt)
	foldedHxDigest := proof.Hx[len(proof.Hx) - 1]
	for i := len(proof.Hx) - 2; i >= 0; i-- {
		foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &alphaNBigInt)
		foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[i])
	}

	digests := []dkzg.Digest{
		foldedHxDigest,
		proof.Z,
	}
	digests = append(digests, proof.witnesses...)
	digests = append(digests, vk.Q...)
	digests = append(digests, vk.Sy...)
	digests = append(digests, vk.Sx...)

	foldedPartialProof, foldedPartialDigest, err := dkzg.FoldProof(
		digests,
		&proof.PartialBatchedProof,
		alpha,
		hFunc)

	if err != nil {
		return fmt.Errorf("failed to fold proof on X = alpha: %v", err)
	}
	var shiftedAlpha fr.Element
	shiftedAlpha.Mul(&alpha, &vk.GeneratorX)
	err = dkzg.BatchVerifyMultiPoints(
		[]dkzg.Digest{
			foldedPartialDigest,
			proof.Z,
		},
		[]dkzg.OpeningProof{
			foldedPartialProof,
			proof.PartialZShiftedProof,
		},
		[]fr.Element{
			alpha,
			shiftedAlpha,
		},
		vk.DKZGSRS,
	)
	if err != nil {
		return fmt.Errorf("failed to batch verify on X = alpha: %v", err)
	}

	// derive beta
	ts := []*curve.G1Affine{
		&proof.PartialBatchedProof.H,
	}
	for _, digest := range proof.PartialBatchedProof.ClaimedDigests {
		ts = append(ts, &digest)
	}
	for _, digest := range proof.Hy {
		ts = append(ts, &digest)
	}
	beta, err := deriveRandomness(&fs, "beta", true, ts...)
	if err != nil {
		return err
	}

	if err := checkConstraintY(vk, proof.BatchedProof.ClaimedValues, proof.WShiftedProof.ClaimedValue, etaY, etaX, gamma, lambda, alpha, beta); err != nil {
		return err
	}
	// foldedHy = Hy1 + (beta**M)*Hy2 + (beta**(2M))*Hy3
	var bBetaPowerM, bSize big.Int
	bSize.SetUint64(globalDomain[0].Cardinality)
	var betaPowerM fr.Element
	betaPowerM.Exp(beta, &bSize)
	betaPowerM.ToBigIntRegular(&bBetaPowerM)
	foldedHyDigest := proof.Hy[len(proof.Hy) - 1]
	for i := len(proof.Hy) - 2; i >= 0; i-- {
		foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM)
		foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[i])
	}
	
	foldedProof, foldedDigest, err := kzg.FoldProof(
		append(proof.PartialBatchedProof.ClaimedDigests,
			proof.PartialZShiftedProof.ClaimedDigest,
			proof.W,
			foldedHyDigest,
		),
		&proof.BatchedProof,
		beta,
		hFunc)

	if err != nil {
		return fmt.Errorf("failed to fold proof on Y = beta: %v", err)
	}
	var shiftedBeta fr.Element
	shiftedBeta.Mul(&beta, &vk.GeneratorY)
	err = kzg.BatchVerifyMultiPoints(
		[]kzg.Digest{
			foldedDigest,
			proof.W,
		},
		[]kzg.OpeningProof{
			foldedProof,
			proof.WShiftedProof,
		},
		[]fr.Element{
			beta,
			shiftedBeta,
		},
		vk.KZGSRS,
	)
	if err != nil {
		return fmt.Errorf("failed to batch verify on Y = beta: %v", err)
	}

	log.Debug().Dur("took", time.Since(start)).Msg("verifier done")

	return err
}

// unpack unpacks evaluations from an array
func unpack(src []fr.Element, dst ...*fr.Element) {
	for i := range dst {
		*dst[i] = src[i]
	}
}

func bindPublicData(fs *fiatshamir.Transcript, challenge string, vk VerifyingKey, publicInputs []fr.Element) error {
	// permutation
	for i := 0; i < len(vk.Sy); i++ {
		if err := fs.Bind(challenge, vk.Sy[i].Marshal()); err != nil {
			return err
		}
	}
	for i := 0; i < len(vk.Sx); i++ {
		if err := fs.Bind(challenge, vk.Sx[i].Marshal()); err != nil {
			return err
		}
	}

	// coefficients
	for i := 0; i < len(vk.Q); i++ {
		if err := fs.Bind(challenge, vk.Q[i].Marshal()); err != nil {
			return err
		}
	}

	return nil
}

func deriveRandomness(fs *fiatshamir.Transcript, challenge string, notSend bool, points ...*curve.G1Affine) (fr.Element, error) {
	if mpi.SelfRank == 0 {
		var buf [curve.SizeOfG1AffineUncompressed]byte
		var r fr.Element

		for _, p := range points {
			buf = p.RawBytes()
			if err := fs.Bind(challenge, buf[:]); err != nil {
				fmt.Println("deriveRandomness", challenge, "err", err)
				fmt.Println("Stack", string(debug.Stack()))
				return r, err
			}
		}

		b, err := fs.ComputeChallenge(challenge)
		if err != nil {
			fmt.Println("deriveRandomness", challenge, "err", err)
			fmt.Println("Stack", string(debug.Stack()))
			return r, err
		}
		r.SetBytes(b)
		if notSend {
			return r, nil
		}
		sendBuf := r.Bytes()
		for i := 1; i < int(mpi.WorldSize); i++ {
			if err := mpi.SendBytes(sendBuf[:], uint64(i)); err != nil {
				return r, err
			}
		}
		return r, nil
	} else {
		var r fr.Element
		recvBuf, err := mpi.ReceiveBytes(fr.Bytes, 0)
		if err != nil {
			return r, err
		}
		r.SetBytes(recvBuf)
		return r, nil
	}
}

const NUM_WITNESSES = 5
const NUM_SELECTORS = 13

func gateFuncSingle(witnesses []fr.Element, q []fr.Element, t0, t1 *fr.Element) {
	t1.Mul(&q[4], &witnesses[1])
	t1.Add(t1, &q[0])
	t1.Mul(t1, &witnesses[0])
	
	t0.Mul(&q[1], &witnesses[1])
	t0.Add(t0, t1)

	t1.Mul(&q[5], &witnesses[3])
	t1.Add(t1, &q[2])
	t1.Mul(t1, &witnesses[2])
	t0.Add(t0, t1)

	t1.Mul(&q[3], &witnesses[3])
	t0.Add(t0, t1)
	
	for i := 0; i < 4; i++ {
		t1.Mul(&witnesses[i], &witnesses[i])
		t1.Mul(t1, t1)
		t1.Mul(t1, &witnesses[i])
		t1.Mul(t1, &q[6 + i])
		t0.Add(t0, t1)
	}

	t1.Mul(&witnesses[0], &witnesses[1])
	t1.Mul(t1, &witnesses[2])
	t1.Mul(t1, &witnesses[3])
	t1.Mul(t1, &q[10])
	t0.Add(t0, t1)
	
	t1.Mul(&q[11], &witnesses[4])
	t0.Add(t0, t1)
	
	t0.Add(t0, &q[12])
}

func gateFunc(witnesses [][]fr.Element, q [][]fr.Element, i uint64, t0, t1 *fr.Element) {
	t1.Mul(&q[4][i], &witnesses[1][i])
	t1.Add(t1, &q[0][i])
	t1.Mul(t1, &witnesses[0][i])
	
	t0.Mul(&q[1][i], &witnesses[1][i])
	t0.Add(t0, t1)

	t1.Mul(&q[5][i], &witnesses[3][i])
	t1.Add(t1, &q[2][i])
	t1.Mul(t1, &witnesses[2][i])
	t0.Add(t0, t1)

	t1.Mul(&q[3][i], &witnesses[3][i])
	t0.Add(t0, t1)
	
	for j := 0; j < 4; j++ {
		t1.Mul(&witnesses[j][i], &witnesses[j][i])
		t1.Mul(t1, t1)
		t1.Mul(t1, &witnesses[j][i])
		t1.Mul(t1, &q[6 + j][i])
		t0.Add(t0, t1)
	}

	t1.Mul(&witnesses[0][i], &witnesses[1][i])
	t1.Mul(t1, &witnesses[2][i])
	t1.Mul(t1, &witnesses[3][i])
	t1.Mul(t1, &q[10][i])
	t0.Add(t0, t1)
	
	t1.Mul(&q[11][i], &witnesses[4][i])
	t0.Add(t0, t1)
	
	t0.Add(t0, &q[12][i])
}

// checkConstraintY checks that the constraint is satisfied
func checkConstraintY(vk *VerifyingKey, evalsYOnBeta []fr.Element, ws, etaY, etaX, gamma, lambda, alpha, beta fr.Element) error {
	// unpack vector evalsXOnAlpha on l, r, o, ql, qr, qm, qo, qk, s1, s2, s3, z, zmu
	hx := evalsYOnBeta[0]
	z := evalsYOnBeta[1]
	witnesses := append([]fr.Element(nil), evalsYOnBeta[2:2+len(vk.Sy)]...)
	q := append([]fr.Element(nil), evalsYOnBeta[2+len(witnesses):2+len(witnesses)+len(vk.Q)]...)
	sy := append([]fr.Element(nil), evalsYOnBeta[2+len(witnesses)+len(vk.Q):2+len(witnesses)+len(vk.Q)+len(vk.Sy)]...)
	sx := append([]fr.Element(nil), evalsYOnBeta[2+len(witnesses)+len(vk.Q)+len(vk.Sy):2+len(witnesses)+len(vk.Q)+len(vk.Sy)+len(vk.Sx)]...)
	offset := 2+len(witnesses) + len(vk.Q) + len(vk.Sy) + len(vk.Sx)
	zs := evalsYOnBeta[offset]
	w := evalsYOnBeta[offset + 1]
	hy := evalsYOnBeta[offset + 2]
	// first part: individual constraints
	var firstPart fr.Element	
	var tmp fr.Element
	gateFuncSingle(witnesses, q, &firstPart, &tmp)

	// second part:
	// (1 - L_{n - 1})(z(, omegaX * alpha)()()() - z(, alpha)()()())
	// + L_{n - 1}(cw * ()()() - pw * z(, alpha)()()())
	var prodfz, prodg fr.Element
	for i := 0; i < len(sy); i++ {
		sy[i].Mul(&sy[i], &etaY)
		sx[i].Mul(&sx[i], &etaX).Add(&sx[i], &sy[i]).Add(&sx[i], &witnesses[i]).Add(&sx[i], &gamma)
	}
	prodg.Set(&sx[0])
	for i := 1; i < len(sx); i++ {
		prodg.Mul(&prodg, &sx[i])
	}

	IDEtaXShifted := make([]fr.Element, len(sy))
	IDEtaXShifted[0].Mul(&alpha, &etaX)
	for i := 1; i < len(IDEtaXShifted); i++ {
		IDEtaXShifted[i].Mul(&IDEtaXShifted[i - 1], &vk.CosetShift)
	}

	var betaEta fr.Element
	betaEta.Mul(&beta, &etaY)

	prodfz.Set(&z)
	for i := 0; i < len(witnesses); i++ {
		tmp.Add(&IDEtaXShifted[i], &betaEta).Add(&tmp, &witnesses[i]).Add(&tmp, &gamma)
		prodfz.Mul(&prodfz, &tmp)
	}

	var one, den fr.Element
	one.SetOne()

	var secondPart, case1, case2, Lxl, oneMinusLxL fr.Element
	Lxl.Exp(alpha, big.NewInt(int64(vk.SizeX))).Sub(&Lxl, &one)
	den.Sub(&alpha, &vk.GeneratorXInv).Inverse(&den)
	Lxl.Mul(&Lxl, &den).Mul(&Lxl, &vk.SizeXInv).Mul(&Lxl, &vk.GeneratorXInv)
	oneMinusLxL.Sub(&one, &Lxl)
	case1.Mul(&prodg, &zs).Sub(&case1, &prodfz).Mul(&case1, &oneMinusLxL)
	prodfz.Mul(&prodfz, &w)
	case2.Mul(&prodg, &ws).Sub(&case2, &prodfz).Mul(&case2, &Lxl)
	secondPart.Add(&case1, &case2)

	// third part Lx0(alpha)*(Z(beta, alpha) - 1)
	var thirdPart fr.Element
	z.Sub(&z, &one)
	thirdPart.Exp(alpha, big.NewInt(int64(vk.SizeX))).Sub(&thirdPart, &one)
	den.Sub(&alpha, &one).Inverse(&den)
	thirdPart.Mul(&thirdPart, &den).Mul(&thirdPart, &vk.SizeXInv).Mul(&thirdPart, &z)

	// forth part Ly0(beta)*(W(beta) - 1)
	var forthPart fr.Element
	w.Sub(&w, &one)
	forthPart.Exp(beta, big.NewInt(int64(vk.SizeY))).Sub(&forthPart, &one)
	den.Sub(&beta, &one).Inverse(&den)
	forthPart.Mul(&forthPart, &den).Mul(&forthPart, &vk.SizeYInv).Mul(&forthPart, &w)

	// Put it all together
	var result fr.Element
	result.Mul(&forthPart, &lambda).Add(&result, &thirdPart).Mul(&result, &lambda).Add(&result, &secondPart).Mul(&result, &lambda).Add(&result, &firstPart)

	var vanishingX fr.Element
	vanishingX.Exp(alpha, big.NewInt(int64(vk.SizeX)))
	vanishingX.Sub(&vanishingX, &one)

	var vHx fr.Element
	vHx.Mul(&hx, &vanishingX)
	result.Sub(&result, &vHx)

	var vanishingY fr.Element
	vanishingY.Exp(beta, big.NewInt(int64(vk.SizeY)))
	vanishingY.Sub(&vanishingY, &one)

	var vHy fr.Element
	vHy.Mul(&hy, &vanishingY)
	result.Sub(&result, &vHy)

	// if result != 0 return error
	if !result.IsZero() {
		return fmt.Errorf("constraints on Y are not satisfied: got %s, want 0", result.String())
	}
	return nil
}
